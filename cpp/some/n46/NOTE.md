## n46 - `QVector` vs `QList`

## Теория о контейнерах

### `QList`

В *Qt 6*, `QVector` раньше был другим классом в *Qt 5*, 
но теперь это просто псевдоним `QList`.

---

В *Qt 5*, `QList` не хранит объекты напрямую,
а вместо них хранит указатели на них (`QVector<T*>` == `QList<T>`?).
Но при добавлении элемента в `QList` происходит копия.
С дополнительным косвенным доступом он вряд ли обеспечит
заявленные преимущества в производительности.

`QList` резервирует пространство до (?) и после.


Перераспределение включает в себя перетаскивание указателей 
вместо конструкторов копий, но теряете пространственную локальность 
фактического `std::deque` или `std::vector` и получаете много выделений в куче.

`QList` ближе к `boost::ptr_deque`
`QLinkedList` аналогичен `std::list`, и имеет все его недостатки.

Использование дополнительной кучи и случайное расположение фактических данных теоретически могут в некоторых случаях *навредить*, но зачастую это *незаметно*.

### `std::deque` 
Пространственная локальность хуже, чем `std::vector`, 
но объекты имеют тенденцию группироваться, 
что дает некоторые преимущества.

### `std::list`
Самым большим преимуществом `std::list` является то,
что вы можете быстро соединить их вместе...
если вы переместите весь диапазон значений в другой `std::list`,
вся операция составит O(1).
Кроме того, гораздо сложнее сделать ссылки в списке недействительными,
что иногда может быть важно.

## Памятка

> Копирование элементов, когда происходит перераспределение памяти.
> Гарантия на то, что ссылки остаются живыми (гарантии относительно ссылок).

## Источники

1. `QVector` против `QList` [here](https://stackoverflow.com/questions/6602036/qvector-vs-qlist)