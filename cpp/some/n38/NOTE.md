## n38 - `std::future; std::packaged_task; std::thread`

## Теория

### Говорим о будущем

Можно строить систему ожидания событий на `condition_variable`. Очень удобный метод для моделей, в которых есть некий субъект, который постоянно ожидает наступления некоторого события. Но существуют и такие ситуации, когда вам необходимо дождаться наступления некоторого события один раз. Такой механизм, существует и именуется он как `future`.

Класс `future` представляет собой обертку, над каким-либо значением или объектом, вычисление или получение которого происходит отложено. `future` предоставляет доступ к некоторому разделяемому состоянию (?), которое состоит из 2-х частей: данные (здесь лежит значение) и флаг готовности. `future` является получателем значения и не может самостоятельно выставлять его; *роль future пассивна*.

Появление, или же вычисление, значения означает, что разделяемое состояние (`future`), содержит требуемое значение и флаг готовности “поднят”. Объект `future` предоставляет исключительный доступ к значению, когда оно было вычислено.

Помимо `future` существует и расширенный вариант, который представляет совместный доступ к разделяемому состоянию. Эта расширенная версия именуется `shared_future`. `shared_future` позволяет нескольким потокам получать уведомления из одного источника. `shared_future` синхронизирует доступ только к `future`, но не к значению, которое хранится в нём (?).

Объект `shared_future` может быть получен из объекта `future`, с помощью метода `future::share`, после чего объект `future`  становится "пустым", т.е. лишается своего доступа к разделяемому состоянию и не может быть в дальнейшем использован для ожидания или получения значения из него.

## Источники

1. Добро пожаловать в параллельный мир. Часть 2: Мир асинхронный [here](http://scrutator.me/post/2012/06/03/parallel-world-p2.aspx)